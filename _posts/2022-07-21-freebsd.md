---
layout: post
title: FreeBSD
---

## Init Main

So freebsd calls `mi_startup` as its first common entry point it seems, at `sys/kern/init_main.c`. Before that, it may be booted from something like GRUB or simply an EFI stub. I think it might also have an MBR stub too.

There, it does a few things. I noticed the first thing it does is to declare pointers to `sysinit` structs. Some double pointers. I think those are meant to be system init tasks, some of which are tabulated. A lot of it is traversing through the sysinit tables' primary and secondary keys (SQL like?), and sorting them, then calling `(*((*sipp)->func))((*sipp)->udata);` to initialise that system. Its done in this manner to make it easy to plug and play a subsystem like the VMM or cpu. And maybe allow dynamic loading of arch dependent subsystems.

`sysinit` is just:

```c
struct sysinit {
 void (*func) (void *arg);
 void *data;
};
```

So a function pointer that takes in some unformatted arg. And a piece of data. The actual data looks like `sysinit_data`, which is a struct containing the filename, debug info, msb, lsb, etc. Of a certain value (in a config file?). `SYSINT()` is called in many places, presumably to start each core subsystem.

## Memory Management

There is arch dependent and arch independent code for it. Normally all arches have a hardware MMU with a set of common page attributes. Like dirty, paged on disk, protected, ro, rdwrite, executable.

Looks like each process (including the kernel) has its own `vm_map`. And a set of `vm_map_entry`. Each `entry` tells you a specific address range being used for that map. This is useful in the kernel for assigning memory ranges for subsystems.

One security feature is that the first 4K-8K of RAM is actually reserved for the kernel. Prob the text or some known data. This eases debugging as well. If you try to null deref via privilege escalation, this invokes a page fault. Since you know what data is there as well, you shouldn't leak any sensitive data in case the code somehow manages to reference a null pointer.

When they say "memory allocator" I think they mostly mean dynamic memory allocation. So not so much as atomic as page allocation itself, but how to allocate general free "areas". An area could be a page. Or a set of pages. Or half a page. But usually prob multiples of the min page size.
