---
layout: post
title: Crypto
---

## And stuff that I'd like to get into

Theres a bunch of other details like cryptocurrency code (UTXO and server and nodes), P2P over TCP/IP

## Bitcoin

Prob [mostly](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSeZLPVKEQH2vLJKNKOZtrJ37iY6n4TTNyyAk7j4hz_wg&s). For bitcoin format.

So I get that: bitcoin usually computes hashes twice. They hash the hash. And mostly SHA-256 or RIPEMD-160 (for keys I think). So basically they generate some bitcoin key from a string? Which they use SHA-256 to hash. Then use RIPEMD-160 to hash that. Or do they use SHA-2 for keygen?

Now you think about it, how does keygen work? Prob a program that has access to the internal code of the program. Maybe its salt? So you can add the salt into some correct input string. Hash that. And get a correct key?

Merkle tree => literally just a binary tree. But stores hashes. These hashes are doubly hashed SHA-256. Of your block I think. Cause your list of transactions gets appended into a single string, which is appended to a block metadata header. Then hashed twice.

Wait you got to ensure an even number of columns (each row of tree must be even) for SHA to work properly. So you just append an extra blank value to the row.

## Quantum Chip

I want to build a quantum chip based on superconductors. I saw them, and they were hella cool. I think its possible to do at room temp with a less complex setup. Since we want it on a chip form too without too much cooling and container overhead. Bascially you gotta make a cooper pair.

So basically for a room temp superconductor. You can exploit its properties and place it on a chip. When it conducts current, it does so with "zero" resistance. So that you can reverse a circuit in a way. Instead of having to go through an AND gate, you design a Hadamard gate.

## Rustc

So rustc. IDK I hate beating around the bush.. But eh the brain will never recover. Why? because you secrelty hope it does.

So after building an AST that prob looks kinda like mine. It gets to start analysing for stuff. Also no need for a symbol table I guess, just store everything in tree. Well maybe later you can use, e.g. HIR/MIR and LLVM.

## AMDGPU

So like modern gpus, you have warp and block scheduling. Instead an instruction at a time like the CPU. You group instructions in sets of 32 called warps. And queue them up in the block scheduler (ring buffer I think). There might be an even higher abstraction in the microcode that converts the command buffers into simpler single instruction threads.

SIMD is with warps right? You can operate on 32 data with one "instruction"?
