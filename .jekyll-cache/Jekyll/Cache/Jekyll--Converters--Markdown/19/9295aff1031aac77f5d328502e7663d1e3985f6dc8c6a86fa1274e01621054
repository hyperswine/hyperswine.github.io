I"ú<h2 id="building-the-soc">Building the SoC</h2>
<p>So we would use chisel (scala library) to build and test the SoC. For in depth testing one can convert to verilog and test on a lower level, or convert to C++ afterwards as well. If wanting to simulate on software, will prob have to use verilator for performance and accuracy.</p>

<h2 id="generating-verilog">Generating Verilog</h2>
<p>Say you have an app in chisel,</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="o">(</span><span class="k">new</span> <span class="nv">chisel3</span><span class="o">.</span><span class="py">stage</span><span class="o">.</span><span class="py">ChiselStage</span><span class="o">).</span><span class="py">emitVerilog</span><span class="o">(</span><span class="k">new</span> <span class="nc">CPU</span><span class="o">,</span> <span class="n">args</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<p>Will generate verilog for your <code class="language-plaintext highlighter-rouge">CPU</code> class. I think it is systemverilog, though Im not 100% sure. Also idk if Verilog and SystemVerilog is both compatible with Verilator since they seem to suggest they only support one or the other or something.</p>

<h2 id="generating-c-and-simulating">Generating C++ and Simulating</h2>
<p>So you do <code class="language-plaintext highlighter-rouge">verilator --cc &lt;verilog files&gt; --Mdir &lt;output_dir&gt; --exe</code> to transpile verilog to executable c++ code. You can also specify <code class="language-plaintext highlighter-rouge">--build cmake</code> to use cmake to build the code into an executable for your platform.</p>

<p>To increase simulation performance, can use <code class="language-plaintext highlighter-rouge">--threads 6</code> to transpile with verilator. This generates code that uses multiple threads.</p>

<p>Btw instead of running verilator directly you can use cmake for the whole thing, e.g.</p>

<figure class="highlight"><pre><code class="language-cmake" data-lang="cmake"><span class="nb">project</span><span class="p">(</span>cmake_example<span class="p">)</span>
<span class="nb">find_package</span><span class="p">(</span>verilator HINTS $ENV{VERILATOR_ROOT}<span class="p">)</span>
<span class="nb">add_executable</span><span class="p">(</span>Vour sim_main.cpp<span class="p">)</span>
<span class="nf">verilate</span><span class="p">(</span>Vour SOURCES our.v<span class="p">)</span></code></pre></figure>

<p>Verilates the verilog to c++ and compiles it to an executable <code class="language-plaintext highlighter-rouge">Vour</code>.</p>

<h2 id="connnecting-to-the-model">Connnecting to the Model</h2>
<p>To hook onto the output model, verilate the verilog which produces <code class="language-plaintext highlighter-rouge">{prefix}.h</code>. Inside contains a <code class="language-plaintext highlighter-rouge">{prefix}</code> class. It contains the interface for your model. So Im guessing here you can e.g. connect an SSD to one of its ports using another model. You would do it in <code class="language-plaintext highlighter-rouge">{prefix}.cpp</code>.</p>

<p>Well ok.</p>
:ET