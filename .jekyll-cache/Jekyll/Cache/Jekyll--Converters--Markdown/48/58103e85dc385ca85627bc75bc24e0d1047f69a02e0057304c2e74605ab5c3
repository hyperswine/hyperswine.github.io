I"ñ<h2 id="yay">Yay?</h2>
<p>So I kinda overcame a bit of the negus in the brain. Anyway It kinda makes sense now. Maybe? The UART0 output now shows. I literally encapsulated within a macro and called it. And it worked. Soâ€¦</p>

<p>Well now we can start building kernel modules that use the kernel manager. The kernel manager is started on <code class="language-plaintext highlighter-rouge">_start</code>. Then the services are basically low level functions and algorithms that are builtin to the kernel code running. Higher level services like device service handler, networkd, loggers should be started after boot as a process running in pseudo kernel mode. Those services can be terminated by the user, with reprecussions. Though usually the kernel just resets or restarts them if something critical were to be messed with. So maybe those startup processes should just run in full kernel mode.</p>

<p>Also to compile a program to work on the kernel, need to first compile any bare metal riscv elf program. Then run that in userspace normally, on a single process thread (software process thread). Kernel should automatically handle multiple app level threads for a process. So async await can be handled by the kernel allocating another hardware thread. But to use higher level functionality, will need syscalls and mmio. For now, many things are just mmio. To call restricted stuff like <code class="language-plaintext highlighter-rouge">open, close, read, write, fork</code> need a syscall API. Can link <code class="language-plaintext highlighter-rouge">syscall.a</code> at compile/link time to ensure rust <code class="language-plaintext highlighter-rouge">extern "C" fn read</code> is found. By default, <code class="language-plaintext highlighter-rouge">syscall.a</code> is placed in the user HFS <code class="language-plaintext highlighter-rouge">/lib/syscall.a</code>.</p>

<p>The shell is very unix like. Pipes and files. I just like it more. But the GUI is very windowsy/macosy with a lot of beautiful graphics and anime.
So that means stuff like ENV variables, .bashrc + .profile (called rei_profile instead), <code class="language-plaintext highlighter-rouge">&gt;&gt;</code>, <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>, <code class="language-plaintext highlighter-rouge">|</code> are all kept. But you are encouraged to do <code class="language-plaintext highlighter-rouge">less file.txt</code> instead of <code class="language-plaintext highlighter-rouge">cat file.txt | less</code>. So the arch is pretty macos/OOP/functional like. The shell is mostly unix based but the bad stuff are taken out. The lower level stuff and other stuff are all from first principles. POSIX API layer is there by default because I dont see a better way to do things yet. I feel like POSIX does make sense with the file handlers, threads, etc. Some other things can be simplified and changed on the fly.</p>

<h2 id="parser--analyzer">Parser &amp; Analyzer</h2>
<p>Hmm I think flex bison is pretty good. I could build something scala like that compiles to LLVM IR. That would be the big goal here. YEA</p>

<h2 id="negus">Negus</h2>
<p>I cant get over the negus. I keep feeling restricted and negusâ€™d. The shame and stuff. I feel like I can go out though. Yea I not only can. I must.</p>
:ET