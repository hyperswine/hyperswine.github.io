<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">Blog | Jasen Qin</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://n.project-spectre.info/blog"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" property="og:title" content="Blog | Jasen Qin"><meta data-rh="true" name="description" content="Blog"><meta data-rh="true" property="og:description" content="Blog"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/img/Rei-Light.png"><link data-rh="true" rel="canonical" href="https://n.project-spectre.info/blog"><link data-rh="true" rel="alternate" href="https://n.project-spectre.info/blog" hreflang="en"><link data-rh="true" rel="alternate" href="https://n.project-spectre.info/blog" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Jasen Qin RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Jasen Qin Atom Feed">





<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.ec02ea49.css">
<link rel="preload" href="/assets/js/runtime~main.018c6d02.js" as="script">
<link rel="preload" href="/assets/js/main.7ba8736e.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">Overview</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Posts</a><a class="navbar__item navbar__link" href="/docs/base/spectre-system">Works</a><a class="navbar__item navbar__link" href="/docs/research/concurrency">Research</a><a class="navbar__item navbar__link" href="/docs/about/resume">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/hyperswine/projects" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search searchBarContainer_NW3z"><input placeholder="Search" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div><div class="searchHintContainer_Pkmr"><kbd class="searchHint_iIMx">ctrl</kbd><kbd class="searchHint_iIMx">K</kbd></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/07/31/post">Assymetric Distribution of Life in the Universe</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/07/19/post copy">Culture Surrounding Early Education</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/06/25/update">Theory of Natural Intelligence</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/05/22/update">Well, Damn</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/11/21/update">Update</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/2023/07/31/post">Assymetric Distribution of Life in the Universe</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-07-31T00:00:00.000Z" itemprop="datePublished">July 31, 2023</time> · <!-- -->2 min read</div></header><div class="markdown" itemprop="articleBody"><p>Ive thought about the drake equation and the fermi paradox quite a bit and kinda came to a view that perhaps there really isnt a paradox or problem with why we dont see aliens. The distances between celestial objects can be very far away, from a few light years to billions.</p><p>Furthermore there can also be a high level of &quot;temporal distance&quot; as the universe seems to be around 13.8 billion years old. Civilisations could have sprung up and gone extinct multiple times or may have even developed so much during such time that they could be comparable to gods. It only took around 10000 years for human civilisations to develop to this extent, where we have relatively useful and powerful technology. And one could wonder what we could end up with given another 10000 years, let alone a million or billion years.</p><p>If string theory were to be true or there are multiple spatial dimensions that objects could move in, perhaps civilisations are able to make use of higher dimensional space and appear almost invisible to us. Furthermore they could be dealing with immense scales of structure and development, like dyson spheres and beyond, and we&#x27;re still trying to find them with much more primitive technology like radio signals and visual data, which they may have already evolved past.</p><p>Other forms of life may also exist but and may be quite prevalent though primitive. In such a case, perhaps it would be harder to detect them. It took relatively long for complex, multicellular life to develop on earth but simple, unicellular life pretty much appeared as soon as the raw materials of water and organic compounds were present in good amounts.</p><p>Perhaps life is highly assymetrical in the universe; either it is very intelligent, or is very primitive. If they are very intelligent, they could already have transcended the usual lifestyles and universal laws we deal with. If they are very primitive, they might not have as much of an impact on their planet and is harder to detect from distances away.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/2023/07/19/post copy">Culture Surrounding Early Education</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-07-19T00:00:00.000Z" itemprop="datePublished">July 19, 2023</time> · <!-- -->2 min read</div></header><div class="markdown" itemprop="articleBody"><p>I think the culture that kids are brought up in does not naturally lead to enlightenment and effective growth. It is basically a everyone for themselves kind of thing where the talented kids get boosted and the attention while the others that might different skill sets are generally just placed there to conform to the standards set. It does not allow an expansion of one&#x27;s creativity from young and lead to a natural curiosity and interest in subjects like mathematics, science, history, etc. Teachers are burdened with 20-30 kids each and have to stay in a room for 8 hours a day. It just seems so inefficient. Think about the times when you actually get interested in something, you might spend hours on end by yourself, researching the task, reading books, writing notes. It almost happens automatically. You dont need to be coerced at all. Yet it seems we are led to be believe the best course of action is to have an &quot;industrial&quot; process of &quot;kids in, kids out&quot;, where its like a factory line from &quot;grade 1 to 12&quot;. Where kids sit down all day, having to look forward and listen for the most part. Sure there may be some interesting dynamics, mostly dependent on the teacher themselves, like perhaps encouraging discussion, giving out creative assignments, engaging with students a bit more at an individual level. But I think as a whole, it just feels quite inefficient and places too much &quot;structure&quot; on kids from young without them exploring these fields in a naturally curious way themselves</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/2023/06/25/update">Theory of Natural Intelligence</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-06-25T00:00:00.000Z" itemprop="datePublished">June 25, 2023</time> · <!-- -->3 min read</div></header><div class="markdown" itemprop="articleBody"><p>I think I have come up with an interesting theory of intelligence. It basically divides &quot;intelligence&quot; into two major aspects in terms of learning, cognition</p><ol><li>capacity</li><li>performance</li></ol><p>and another aspect: need.</p><p>Humans have a very high capacity for learning and can learn deep, complex rules and facts. Like, the nature of weather, what causes wind, what causes death. Animals like whales also seem quite intelligent but do not have the same level of complexity in their neocortex, i.e. they may not have as much &quot;grey matter&quot; in proportion to their white matter</p><p>Human intelligence is also quite performant in terms of reasoning, arithmetic, planning and creativity. You can think about many different scenarios and consider many different factors when planning. And its usually quite decent, depending your current mental state. Sometimes its faster, sometimes its slower. Perhaps due to cognitive load and anxiety, or a lack of stimulus. Humans, when given the right stimulus and foundational knowledge, are capable of many things compared to other animals.</p><p>Creativity could be an aspect of &quot;capacity&quot;, like when you have to find a workaround to solve an issue and so you leverage your existing knowledge base to identify a different concept that could be potentially applied to the problem.</p><p>Performance also implies how fast you can learn something and how much you can leverage your existing knowledge  BASE to aid your reasoning and understanding of a subject.</p><p>But that does not necessarily mean that humans have a &quot;need&quot; to do something or create something. You do not always need to think about e.g. what happened at the beginning of the big bang, or whats on the other side of the moon. You dont have to reinvent the wheel either, you could use other people&#x27;s knowledge and works. Nor do you have to completely understand how it works deep down, just how to interface with it. Much of human understanding seems to have derived from individuals seeking out knowledge and understanding of concepts and things we face everyday. Instead of just treating them like black boxes. For example, the human body is very complex, and for a long time, it was not known how such bodily processes worked exactly. Perhaps some general details, but things like pathogens and microorganisms were all around us yet were not discovered until somewhat recently during the scientific revolution.</p><p>Creativity could be also be an aspect of &quot;need&quot;. In the finding a workaround example, perhaps you are pressured by e.g. your boss to finish your job by the end of today. Using traditional methods, it would take too long. So you have a strong incentive to perhaps increase the performance of your brain to think about concepts more abstractly, and potentially find another alternative. In humans, this might e.g. engage your right brain hemisphere more, which may have evolved to process abstract thought.</p><p>What this also means that while an octopus or whale could potentially have pretty high performance and capacity for complex thought, planning and learning. But they may not have the right incentives to push them to leverage their intelligence like the way humans have in terms of building civilisations.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/2023/05/22/update">Well, Damn</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-05-22T00:00:00.000Z" itemprop="datePublished">May 22, 2023</time> · <!-- -->7 min read</div></header><div class="markdown" itemprop="articleBody"><p>I cleaned up this space a bit recently. Many things have happened since then. I think I let my uninformed imagination get to me quite often and its hard to know when your just making up some random stuff in your mind or when you actually stumbled upon something significant. The CSTC circuits and gut-brain axis can make humans do some stupid things, whether that be getting too tense or anxious about some random stuff or freezing them in place, repeating such a cycle.</p><p>And AI. Well guess my predictions came to be true. GPT really is becoming the new thing everyone will not stop talking about. Whether that be scientists, the ignorant masses or scammers.</p><p>I don&#x27;t really know what&#x27;s going to happen anymore, I feel quite conflicted and chaotic. My mind never ceases to bring up some bizzare  thought. Its like the more I do what I do, the less I feel like I really know anything at all. Like Im trying to become so open minded, considering all the possible timelines, technologies, cases, reasons for things happening that my brains have fallen out.</p><p>Persistent data structures? Functional programming? Dataflow programming? Logic programming? Proofs? Concurrency? Metaprogramming through metaobjects? Macros? Procedural programming?</p><p>Haskell? Scala? Clojure? Racket? Idris? APL? Rust? Pharo? Prolog? Mercury? Julia? Python? Elixir? Erlang? ATS?
All such languages have their pros and cons, especially on the current hardware-software landscape. Many were developed to work with existing APIs or ways of thinking. I think research languages like haskell and coq are better in this regard, so as languages like APL and smalltalk. With regard to intergration with existing interfaces and simplicity, python takes the cake, and perhaps julia too. Many tools are built using python, like APT.</p><p>I don&#x27;t know what I even want either. I feel like I get quite nervous sometimes when coding and Im unable to do something that would be usually quite straightforward, even something as simple as reading the error messages from compilation with langs like haskell. That being said having easier interfaces would probably quite beneficial. Mojo might be a decent language if it gets released... apparently its quite fast and fixes some of python&#x27;s issues.</p><p>I think I want something like python and haskell with rust level static analysis and safety. The simplicity and expressiveness when coding in python feels unmatched. Perhaps its also because I feel more familiar with it, like rust. But Im also quite familiar with C, C++, and JS but I dont really feel like those are as good to write in and I make frequent mistakes in them. Having optional types might be a big factor. As well as a single interface to write collections in. Whether that be specifications like a struct or an array of values or a combination. I think idris does particularly well in that regard.</p><p>I also want to be able to match on simple maths logic like <code>x - y &gt; 0</code> on a single arm like:</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match x, y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case x - y &gt; 0 =&gt; ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// in addition to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">match x, y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case (1, 0) =&gt; ...</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Scala&#x27;s unapply is also quite cool, I haven&#x27;t made much use of it but I feel like this way of thinking is quite ingenious (I think haskell has it too).</p><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">AddOne:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x: _</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    y: _</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match: (x, y) =&gt; Self(x+1, y+1)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Im not quite sure how I feel about smalltalk&#x27;s metaobject and everything is an object thing. I dont see much of a reason to add methods at runtime, but checking what methods you do have could be useful. That would add to the runtime storage overhead but ehh. Apparently it could be quite useful to modify the method definition at runtime if there&#x27;s a bug or something. Maybe attach a remote debugger and tell the VM to change the object&#x27;s method. Kind of like self modifying code as well I guess. It could be quite useful for security and pushing new features, but I have yet to see it in practice. In theory you could push out an updated method to all running instances quite trivially, without having to recompile or restart the system. Combined with a very simple, resilient hardware system, it could be a very potent method of running programs.</p><p>Im also not quite sure about logic programming. On one hand, it seems quite powerful and concise in terms of representing classes of problems related to knowledge bases and queries. On the other hand, I dont really think its better than functional programming implementations like haskell at writing up complex logic for dealing with lists. I think an observation here is being able to easily express logic to deal with multi dimensional arrays. Python isnt too bad at it, but the syntax can be a bit confusing when people use <code>arr[1, 2]</code> or when you have many dimensions and you have to keep track of what dimension it is in. Perhaps something like <code>rust-analyser</code> could help here with its automatic annotations, which could be applied to tensor accesses statically or dynamically. Maybe something like an <code>ith</code> dimension, and the server is smart enough to detect a shortening of the dimensions for example to <code>i-1</code>.</p><p>Im not sure about proofs. It seems like you can pretty much prove everything, though the turing decidability problem is a limiting factor. So you could have something where you are able to prove 99% your functions terminate and even &quot;statically&quot; evaluate calls if they wont take up too much space. And decompose functions from a complex form to a simple form. Maybe through graph theory or HoTT. I heard its possible, through generating different, simpler functions and testing that against the original. Paired with randomised algorithms, the sky looks blue. Dependent types are also often talked about in proofs, and is a key component it seems, at least if you want static proofs. Theres total functional programming which actually seems quite good too, but if I will sacrifice expressiveness for it, then nevermind. It seems like the gist of most proof languages involve annotating down a function to ensure that the recursive case eventually reaches the base case through e.g. decrementing the required value at each step. There can not be any steps where you might or might not return a value, you must do so, and that value must get you strictly closer to your goal by some non-zero amount.</p><p>Verification is another thing. I haven&#x27;t tried out a verification tool yet so I dont really know how to make of it. Some say its a waste of time. Some say its only good for things you want to not fail under any circumstances, like a plane&#x27;s software or a hospital. I think I should look into it some more, but if your model or spec is flawed, wouldnt your software be too?</p><p>Performance. Ive looked a bunch of articles and like... damn. Performance seems very hard to get right in the current software-hardware landscape. Whether that be through compiler optimisation, syscall optimisation, algorithmic optimisation, adding more potent hardware, faster and more memory, etc. On the compiler optimisation front, you have tons of ways to make a program potentially faster, often at the cost of more memory usage (time-space tradeoff). Sometimes though it could be as simple as removing redundant instructions and memory accesses, or batching them together. Maybe prefetching too, but tbh I haven&#x27;t seen it been used myself, though I think LLVM should insert them (it goes against lazy evaluation though I think). I also dont even think high performance is that much of a problem. Rather its more like consistent, good enough performance. I would much rather play a game on a consistent 30 fps than having FPS spikes and valleys from 40-80fps even though the latter has a higher average fps. I also dont pay attention to variable resolution as long as its not too big of a gap, which means the flow of content is probably much more important than its sharpness or detail.</p><p>To that end, on the consistent performance front, it might be good to start off with a lazy language and a deterministic set of hardware and low level interfaces. The scheduler could possibly use a randomised algorithm though, which can be a bit ironic but my intuition tells me it could work out quite well.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/2022/11/21/update">Update</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-11-21T00:00:00.000Z" itemprop="datePublished">November 21, 2022</time> · <!-- -->One min read</div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="archived-posts">Archived Posts<a class="hash-link" href="#archived-posts" title="Direct link to heading">​</a></h2><p>Any post older than this is a rough collection of my thoughts. You can just forget they even exist.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-new-page">A new page<a class="hash-link" href="#a-new-page" title="Direct link to heading">​</a></h2><p>I&#x27;ll try to make newer posts higher quality and actually ending somewhere. With a list of edits at the bottom.</p><p>Its also getting close to the first iteration I think. For neutron on star64.</p></div></article><nav class="pagination-nav" aria-label="Blog list page navigation"></nav></main></div></div></div></div>
<script src="/assets/js/runtime~main.018c6d02.js"></script>
<script src="/assets/js/main.7ba8736e.js"></script>
</body>
</html>