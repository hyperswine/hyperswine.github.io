<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">Higher Peformance Prolog | Jasen Qin</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://n.project-spectre.info/blog/2024/01/14/high-perf-prolog-impl"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Higher Peformance Prolog | Jasen Qin"><meta data-rh="true" name="description" content="Lets think about how we can make a high performance implementation of Prolog."><meta data-rh="true" property="og:description" content="Lets think about how we can make a high performance implementation of Prolog."><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2024-01-14T00:00:00.000Z"><link data-rh="true" rel="icon" href="/img/Rei-Light.png"><link data-rh="true" rel="canonical" href="https://n.project-spectre.info/blog/2024/01/14/high-perf-prolog-impl"><link data-rh="true" rel="alternate" href="https://n.project-spectre.info/blog/2024/01/14/high-perf-prolog-impl" hreflang="en"><link data-rh="true" rel="alternate" href="https://n.project-spectre.info/blog/2024/01/14/high-perf-prolog-impl" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Jasen Qin RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Jasen Qin Atom Feed">





<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.ec02ea49.css">
<link rel="preload" href="/assets/js/runtime~main.fc070c24.js" as="script">
<link rel="preload" href="/assets/js/main.04e0b186.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">Overview</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Posts</a><a class="navbar__item navbar__link" href="/docs/base/spectre-system">Works</a><a class="navbar__item navbar__link" href="/docs/research/concurrency">Research</a><a class="navbar__item navbar__link" href="/docs/about/resume">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/hyperswine.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search searchBarContainer_NW3z"><input placeholder="Search" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div><div class="searchHintContainer_Pkmr"><kbd class="searchHint_iIMx">ctrl</kbd><kbd class="searchHint_iIMx">K</kbd></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2024/04/23/observations-on-open-source-1">Observations</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/2024/01/14/high-perf-prolog-impl">Higher Peformance Prolog</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/09/15/meta-computer">Metacomputer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/09/07/antarctican-english">Antarctican English</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/08/10/Solaros">Solaros</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">Higher Peformance Prolog</h1><div class="container_mt6G margin-vert--md"><time datetime="2024-01-14T00:00:00.000Z" itemprop="datePublished">January 14, 2024</time> Â· <!-- -->9 min read</div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>Lets think about how we can make a high performance implementation of Prolog.</p><p>I think certain annotations like mode declarations and input output declarations can help.
Those will be optional. What I dont want is types I think, that would definitely make it less prolog-like.</p><p>If not using the cut operator, maybe prolog predicates could be mapped to SAT problems relatively simply.
If so, external high performance SAT solvers could be used.</p><ol><li>Parallelism using lightweight greenthreads and maybe a userspace threading library could help.
Like it could basically identity independent parts of the program and aggressively try to parallelise them.
Too fine grained, probably not good. Especially considering the processors we use right now.</li></ol><p>Per-Goal Basis: Parallelizing on a per-goal basis could be a promising approach. Each goal in Prolog can be considered a reasonably self-contained unit of computation, making it a good candidate for parallel execution. Maybe do dependency analysis on each goal beforehand to see if you can parallelize it &quot;embarrassingly&quot; or might require extra synchronization.</p><p>Lists and collections could potentially be parallelized at a very fine level of granularity in terms of vectorized instructions.
One could annotate that a list of N elements of integers could be represented as say a list of N 32-bit integers, and be represented in a tightly packed array that could be easily amenable for vector operations like vector addition.</p><p>Could complicate backtracking quite a bit. Might require synchronization.</p><p>Biggest issue is I think the fact that modern processors are kind of setup for coarse grained parallelism, on a per-process basis.</p><ol start="2"><li>More efficient backtracking. Not sure what it might look like. Maybe some hueristics and things to make searching potentially more optimal.</li></ol><p>Backjumping and Learning: Instead of traditional backtracking, use techniques like backjumping, where the system jumps back more than one level in the search tree when a dead end is reached. Learning from failed paths to avoid similar paths in the future can also be efficient.</p><p>Heuristic methods can be very effective but require domain-specific knowledge.</p><ol start="3"><li>Maybe type inference where possible. By assigning concrete types, just in time to queries, it could make the code more lightweight if we can map the values to primitive data types like 32-bit integers rather than abstract objects.</li></ol><p>How to do this? It feels like some cases could be easier and straightforward while other cases harder. The general plan is to be able to map complex prolog data and values to low level primitives.</p><div class="language-pl codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-pl codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">%% what is T? in normal prolog, it would just be a generic type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">%% but we can infer from the use of T in t(T)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x(T) :- t(T).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">%% t is defined here as 1 and &quot;x&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">%% that means statically we can say that t(T) where T = union(num, string)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">%% since we are only given a value = 1 for num, we can further optimize and say num = int8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">%% x is also a single string, and we could turn that into an vector of 1-byte each to represent ASCII because we dont need UTF-8 encoding</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">%% we could also choose to further optimize string down to a single char rather than a vector or array, since we are only given a string with 1 element</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">t(1).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">t(&#x27;x&#x27;).</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In this example, we can apply type inference based on the original data available. However, if the database changes, like we <code>assert</code> something into the database:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">t(y(z)).</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This could then change the type of <code>t(T)</code>. Does that mean we should then recompile our initial program to change the type signature and the way that <code>t(T)</code> and all the predicates that depend on it work?</p><p>Version it, and recompile. Maybe not even version if we dont want, but can easily also redo it or use the existing predicate and only recompile on demand if the new version actually should get used.</p><p>Maybe we can mark it as dirty. Then use the dynamically typed version while it is recompiling. The shell could show something like <code>(detected new type... recompiling)</code>.</p><ol start="4"><li>Ad hoc optimizations.</li></ol><p>Maybe we could optimize on the fly based on the types of queries we receive.</p><ol start="5"><li>Memory Management</li></ol><p>Maybe using linear types or uniqueness types a la rust could be useful for memory management. Since we are basically threading data into goals, we could dont have to make copies of the data each time.</p><p><strong>Linear types</strong>, <strong>CPS</strong> and <strong>primitive data type inference</strong> could all be useful for reducing memory load and increasing cache efficiency.</p><p>Maybe more aggressive tabling, and tabling by default.</p><ol start="6"><li>Semantics Changes</li></ol><p>Maybe instead of treating predicates like function calls with stack frames. We instead use a continuation passing style where we are always threading the caller context through to the next caller, so that it can return if need be. We basically pass the current continuation to the next.</p><p>But will probably still use stack frames for keeping track of local memory, unless we dont create more data.</p><p>Hybrid Approach: CPS could be used selectively for performance-critical parts of the code, while keeping traditional stack-based execution for other parts.</p><ol start="7"><li>Concurrency Features at Hardware Level</li></ol><p>Generally cores right next to each other in the processor TOPOLOGY can much more quickly communicate with each other, by factors of 10x. Its already not too bad, like 20ns to 100ns. But it might be hard to directly schedule threads that are topology aware, generally the OS&#x27;s job since it exposes a thread API.</p><ol start="8"><li>Spatial and Temporal Optimizations</li></ol><p>Tightly packing collections into say an array like structure or struct of arrays could be quite cogent.
Maybe try to use hueristics to invoke a goal that would be physically and temporally close to goals that already exist.</p><p>Specialized data structures.</p><ol start="9"><li>More Extreme Considerations</li></ol><p>Maybe GPUs and tensor processsing hardware could be used instead. It might add more latency, but could be highly effective for workloads where it is more about searching and simple computations than sequential execution.</p><p>Parallel Search and Pattern Matching: Prolog&#x27;s search and pattern matching operations, which are often highly parallelizable, could greatly benefit from GPU acceleration. GPUs, with their thousands of small cores, are adept at handling such massively parallel computations.</p><p>Data-Intensive Operations on large sets of data, especially those that involve simple, repeatable computations (like processing lists or arrays), can be significantly sped up on GPUs.</p><p>Standard vs. Accelerated Predicates: Offer both standard predicates like <code>maplist</code> for CPU execution and specialized versions like <code>maplist_accel</code> for GPU-accelerated execution. This allows the programmer to explicitly choose the acceleration for computationally intensive tasks.</p><p>Use Julia for interop and calling external things, not C, or C but ensure that it is very portable.
Or compile the julia program to C and link that. Probably going to have to use julia to interact with LLVM.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="syntax">Syntax<a class="hash-link" href="#syntax" title="Direct link to heading">â</a></h2><p>I also think it could be an opportunity to potentially improve the syntax in an optional manner. Like you can also make it use a whitespace sensitive approach where you dont have to use <code>,</code> to compose statements in CONJUNCTION. And instead of <code>predicate(Args...)</code>, use <code>predicate Args...</code> in certain contexts like elixir.</p><p>With whitespace sensitivity, the <code>.</code> period could also be omitted in some contexts.</p><p>I think having higher order predicates like <code>P1(P2(Args...))</code> where P1 and P2 are parameters is also a must. Maybe builtin lambda functions too, but Im not sure, that might make it not work very well with existing implementations. Maybe just the <code>yall</code> library in SWI-Prolog is good enough, prolog is not a functional programming language.</p><p>So this would be valid</p><div class="language-prolog codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-prolog codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ancestor X Y :- father X Z, father Z Y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">%% or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ancestor X Y :-</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  father X Z</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  father Z Y</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-do-existing-prolog-implementations-do-their-thing">How do existing Prolog implementations do their thing?<a class="hash-link" href="#how-do-existing-prolog-implementations-do-their-thing" title="Direct link to heading">â</a></h2><p>Many implementations use the WAM as a basis. The original implementation based on (I think cambridge or some other english university) was designed by David Warren and kind of worked quite well. It was quite powerful in terms of what it could do, its features. I think it wasnt the greatest in performance, but was good enough for many things like AI and databases and searching/planning.</p><p>SWI-Prolog, made by Jan Wielemaker is probably the most widely used and developed version. It supports ISO Prolog to large extent, though not sure if its fully compliant. I&#x27;ve read some of its source code and it looks decent for a program that was started a while back. It beats other open source implementations in performance by quite a bit, modern and old alike: scryer-prolog, eclipse prolog, etc. I heard good things about scryer-prolog too, but last I checked its benchmarks were okay-ish but not as competitive as SWI.</p><p>Then theres SICSTus, probably the gold standard in high performance prolog. It seems to use a combination of JIT compilation and hueristics to achieve pretty high performance. By almost an order of magnitude or two compared to SWI sometimes. It probably also does type inference and some complex memory representation and management. Maybe some complex and efficient backtracking too. It does compile to native code, probably something it made itself as it is quite a bit old now (I dont think it uses LLVM, though maybe newer versions might). JIT does incur some initial latency and therefore time penalties but can more than make up for it when it gets going. Things like cranelift for WASM could also speed up JIT compilation, and a WASM runtime to allow near native performance in many cases (or so Ive heard, probably should look more into it).</p><p>I noticed in many prolog implementations, there is also a lot of checking. A lot of checking between executions. It might have been fine back then to make sure it actually works, but the checking Im talking about are things like just seeing whether or not an operation succeeded. I think if we want high performance, we really do need to minimize dynamic checks where possible. Maybe type inference could help with that, and dynamic types otherwise rather than a cursed mix of static-ish operations on a virtual machine.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/2024/04/23/observations-on-open-source-1"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Observations</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/2023/09/15/meta-computer"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Metacomputer</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#syntax" class="table-of-contents__link toc-highlight">Syntax</a></li><li><a href="#how-do-existing-prolog-implementations-do-their-thing" class="table-of-contents__link toc-highlight">How do existing Prolog implementations do their thing?</a></li></ul></div></div></div></div></div></div>
<script src="/assets/js/runtime~main.fc070c24.js"></script>
<script src="/assets/js/main.04e0b186.js"></script>
</body>
</html>