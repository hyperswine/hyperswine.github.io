<!doctype html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Eletei &middot; The enlightened site
    
  </title>

  <link rel="stylesheet" href="http://localhost:4000/public/css/poole.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/syntax.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="http://localhost:4000/public/favicon.ico">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://localhost:4000/atom.xml">
</head>

  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="">
          Eletei
        </a>
      </h1>
      <p class="lead">Made by yours truly. </br></br>Fact: the masses will enter the the critical stage of the dejection process in around a 8.0 years. Until then, we shall meet again.</br></br></p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item active" href="/">Home</a>

      

      
      
        
          
            <a class="sidebar-nav-item" href="http://localhost:4000/about.html">About</a>
          
        
      
        
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="http://localhost:4000/project.html">Project</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <span class="sidebar-nav-item">Currently v3.0.0</span>
    </nav>

    <p>&copy; 2022. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2022/01/28/neutron-update.html">
        Neutron Update
      </a>
    </h1>

    <span class="post-date">28 Jan 2022</span>

    <h2 id="running-neutron--arcboot-on-spectrum-soc">Running Neutron + ArcBoot on Spectrum SoC</h2>
<p>So we want to compile Neutron to a .lib and link with arcboot.o to form <code class="language-plaintext highlighter-rouge">kernel.img</code>. This image can then be flashed onto a virtual drive <code class="language-plaintext highlighter-rouge">ssd.vhd</code> and placed on the host machine, e.g. <code class="language-plaintext highlighter-rouge">dev/ssd.vhd</code>. Then use verilator to simulate the SoC (RV-1 + PCIE + HDMI/UART for now). So I’d have to somehow connect the PCIE 4.0 lane to ssd.vhd, or we have to simulate an SSD within the SoC and flash the image onto their beforehand, after compiling to verilog. Then I’d have to link the UART port to the output of the terminal somehow, maybe thats possible somehow, with verilator.</p>

<h2 id="so-far">So far</h2>
<p>Figured out how to create a basic bootloader in asm and kernel in rust and link them into a bootable img for qemu riscv64 (spike board). The output works. Im not sure about all the different views, guessing thats got something to do with the main QEMU monitor view vs UART serial view or something. Idk how to get it to print to the main monitor, if that even makes sense. The bootloader does seem to work I think, because it does go into <code class="language-plaintext highlighter-rouge">kernel_main</code>. The other stuff like setting up the stack and program segements for the kernel in RAM doesnt seem to matter too much rn. I dont really get how to compile all the rust code to a .lib/.o file, I did <code class="language-plaintext highlighter-rouge">--emit=obj</code> which seemed to emit some random <code class="language-plaintext highlighter-rouge">.o</code> file in <code class="language-plaintext highlighter-rouge">target/debug/deps/</code> instead of <code class="language-plaintext highlighter-rouge">target/neutron/</code> or something. It also emits a different obj file name sometimes and doesnt delete the old one. So I dont think this is how one is meant to be cross compiling rust. I dont really get it then, maybe its better and recommended to link with rustc directly somehow, by specifying <code class="language-plaintext highlighter-rouge">boot.S</code> and <code class="language-plaintext highlighter-rouge">linker.ld</code> when we build for riscv64gc? I think there was a way to do that but idk rn and a bit confused.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2022/01/27/neutron-update.html">
        Neutron Update
      </a>
    </h1>

    <span class="post-date">27 Jan 2022</span>

    <h2 id="tdd-and-full-suite">TDD and Full Suite</h2>
<p>I was thinking that TDD really helped. Heh that 1531 course truly made sense. When you start with tests you start to see how the program should work. This is nice when you try kernel deving. I guess program deving also works nicely too. Another thing is to start from the top and go down. Then you can see how everything fits in together within the guidelines of software eng. Stuff like KISS, DRY, loose coupling, first principles. Starting from the bottom also helps if you have restrictions. For hardware we are restricted by current technologies (for the next e.g. 3-5 years) and economical reasoning. We want preferrably low costs and high performance within the bounds of what is currently possible. And research and new tech is apparently also costly but idk, I kind of like it too.</p>

<p>So stuff like new software isnt as problematic as new hardware. Things at the highest level like software apps, GUI, etc are also limited by what the hardware and optimisations can provide. But it should be fine I think. If you start from the hardware and build up as well as simultaneously starting from what the people need for the next few years and build down, you eventually arrive at a nice concept for a kernel. I think such conception would be minimalistic in its overall memory and performance footprint. According to the latest guidelines of seng and laws of nature, things should be at the lowest energy level and not be wasteful. Individualist, single responsibility. So maybe pluggable kernel modules in a dir called <code class="language-plaintext highlighter-rouge">/mods</code> or something like git submodules pluggable into <code class="language-plaintext highlighter-rouge">/mods</code>? Then have a similar API to load such modules between certain layers. E.g. a driver module plugs into <code class="language-plaintext highlighter-rouge">/driver/mod</code> and a higher level, e.g. graphics module plugs into <code class="language-plaintext highlighter-rouge">/service/mod</code>. Then the graphics can be decoupled almost completely from the core manager logic and if you wanted to update it you can easily update and replace the logic without having to touch the core kernel logic. You would still have to change the app-graphics service interface and code it seems.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2022/01/25/neutron.html">
        Neutron Update
      </a>
    </h1>

    <span class="post-date">25 Jan 2022</span>

    <h2 id="basic-testing">Basic Testing</h2>
<p>After looking and thinking about how I should verify that the kernel functionalities work, I thought having unit tests built into the modules themselves + testing one function at a time + compiling on x86 host was a good idea. At first I also specified a x86_64 pc windows triple, but it just needs to be different from the main build architectures riscv and arm. So thats what x86 is good at, testing.</p>

<p>Esp since the final executable is small and fits nicely in instruction cache. The kernel code prob wont so one of the things I was thinking was to make the instruction cache bigger on a nice risc v cpu designed by no other than CSwine himself.</p>

<p>The most important things are memory management. Esp the specific alloc and dealloc functions. They should work nicely. And so should the dynamic boxes like KVec and KBox which would be used all throughout the kernel. And provide the allocation for <code class="language-plaintext highlighter-rouge">std</code> if one were to implement it.</p>

<p>The other big stuff are the drivers. Testing the drivers… Maybe a whole another thing. Drivers could be a separate crate altogether. In linux they make up over 50% of the codebase but they do try to support everything. Modern devices are quite complex and so the interface and control of them are naturally quite complex too. The drivers themselves dont need to compile per se? Or the fact that they are mostly platform agnostic given that we have a defined API that we’re going to use for the kernel - driver interface. So we can compile and test the drivers on any platform, like x86 even though Id prefer them to be optimised for risc-v or a certain platform (windows, mac, linux does this too)</p>

<p>Well another thing is stuff like rpi drivers. I want to make it work on rpi4b. If the tests work then it shouldnt have any high level difficulties unless we’re doing more than just terminal stuff. Then int tests are key. Those rpi drivers would prob go under drivers/rpi/.. Stuff optimised for riscv, e.g. spectro hardware would go under drivers/spectro/..</p>

<p>For some spectro hardware maybe we can make an all in one driver “file/source” code to control my spectrum soc idea? Or maybe not. If the components have similar interfaces as isolated components would then we can just use separate source driver files. And separate modules for each component if its quite big and complex like NIC and GPU.</p>

<h2 id="complex-testing">Complex Testing</h2>
<p>I dont really know but got a general idea. You test many functionalities together and test higher level abstractions instead of atomic functions.
But the way I kind of set the project out makes it a bit awkward to maybe do. But it is the thing with Rust OS on multiple arch I guess.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2022/01/23/submarine-idea.html">
        Submarine
      </a>
    </h1>

    <span class="post-date">23 Jan 2022</span>

    <h2 id="so-a-submarine">So a submarine…</h2>
<p>A really cool thing. You can dive up to hundreds of metres and stay for a long time. I think the deepest was like 10km, a special sub for the mariana trench.
So you have horizontal stabiliers or ‘fins’ that change the angle of attack. When you dive you want a low AOT to more efficiently cut through the water as the ballast fills. When you rotate the fins counterclockwise (to the front), the flow of water is greater at the top than at the bottom, forcing the submarine down even more. When you rotate it clockwise, it does the opposite and the flow of water is greater at the bottom of the fin, pushing the vessel up. Pushing the water out of the ballast will then further add to its buoyancy as it becomes less dense and speedily charges upwards.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2022/01/21/what-to-do-now-neutron.html">
        Neutron Update
      </a>
    </h1>

    <span class="post-date">21 Jan 2022</span>

    <h2 id="what-to-do-now">What to do now?</h2>

<p>I kind of want to just go at it.</p>

<p>I think maybe the filesystems.</p>

<p>I want it working at each iteration so idk. Maybe we just keep writing stuff up and compiling and linking to the lib.</p>

<p>No we should get some QEMU tests up. So we test with cargo on unittests. Then we test on qemu with integration tests.</p>

<p>I want to make a writer that writes to the screen of qemu. I think we can just rip off phil os for that.</p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="http://localhost:4000/page4">Older</a>
  
  
    
      <a class="pagination-item newer" href="http://localhost:4000/page2">Newer</a>
    
  
</div>

    </div>

  </body>
</html>
