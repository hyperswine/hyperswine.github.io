"use strict";(self.webpackChunkprojects=self.webpackChunkprojects||[]).push([[728],{3905:(e,a,t)=>{t.d(a,{Zo:()=>u,kt:()=>d});var n=t(7294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function s(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function l(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?s(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=n.createContext({}),c=function(e){var a=n.useContext(i),t=a;return e&&(t="function"==typeof e?e(a):l(l({},a),e)),t},u=function(e){var a=c(e.components);return n.createElement(i.Provider,{value:a},e.children)},p={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},m=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=c(t),d=r,h=m["".concat(i,".").concat(d)]||m[d]||p[d]||s;return t?n.createElement(h,l(l({ref:a},u),{},{components:t})):n.createElement(h,l({ref:a},u))}));function d(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var s=t.length,l=new Array(s);l[0]=m;var o={};for(var i in a)hasOwnProperty.call(a,i)&&(o[i]=a[i]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var c=2;c<s;c++)l[c]=t[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5417:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>i,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var n=t(7462),r=(t(7294),t(3905));const s={date:new Date("2022-12-17T00:00:00.000Z"),name:"Jasen Qin",title:"Scala Book",url:"https://github.com/hyperswine",email:"jasen.qin33@gmail.com"},l=void 0,o={unversionedId:"research/scala-book",id:"research/scala-book",title:"Scala Book",description:"Scala, A Versatile and Expressive Language",source:"@site/docs/research/scala-book.md",sourceDirName:"research",slug:"/research/scala-book",permalink:"/docs/research/scala-book",draft:!1,tags:[],version:"current",frontMatter:{date:"2022-12-17T00:00:00.000Z",name:"Jasen Qin",title:"Scala Book",url:"https://github.com/hyperswine",email:"jasen.qin33@gmail.com"},sidebar:"research",previous:{title:"Rei Language",permalink:"/docs/research/rei-1"}},i={},c=[{value:"Scala, A Versatile and Expressive Language",id:"scala-a-versatile-and-expressive-language",level:2},{value:"Modelling",id:"modelling",level:2},{value:"Common Issues",id:"common-issues",level:2}],u={toc:c};function p(e){let{components:a,...t}=e;return(0,r.kt)("wrapper",(0,n.Z)({},u,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"scala-a-versatile-and-expressive-language"},"Scala, A Versatile and Expressive Language"),(0,r.kt)("p",null,"Scala is highly versatile and expressive. It includes features from object oriented programming, functional programming, metaprogramming (reflection and macros) and compiles to java bytecode. It is able to operate quite well with java libraries and is one of the main sticking points."),(0,r.kt)("p",null,"Scala 3 has many great improvements, including syntax and features. The introduction of python-style indentation sensitive blocks is such an ergonomic decision. But feature wise, we have some very important and useful things:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Top level ",(0,r.kt)("inlineCode",{parentName:"li"},"def"),"s. It is now possible to do ",(0,r.kt)("inlineCode",{parentName:"li"},"def")," at a top level"),(0,r.kt)("li",{parentName:"ul"},"Actual algebraic datatypes with ",(0,r.kt)("inlineCode",{parentName:"li"},"enum"),"s"),(0,r.kt)("li",{parentName:"ul"},"Dependent function types through directly using a value in a parameter and ",(0,r.kt)("inlineCode",{parentName:"li"},"{type}")," annotations"),(0,r.kt)("li",{parentName:"ul"},"Given imports")),(0,r.kt)("h2",{id:"modelling"},"Modelling"),(0,r.kt)("p",null,"Scala's extensive support for OOP and FP make it very expressive for modeling many different types of scenarios. ADTs make it easy to model static domains where there's hierarchical data or data that can exist in multiple different forms."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"// algebraic data types\nclass ADT:\n  case Case1\n  case Case2\n\n// same as\nclass ADT:\n  case Case1, Case2\n")),(0,r.kt)("p",null,"Functions in scala can be curried (multiple parameter lists) and in scala 3, can declare types that can be parameterized over values."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"class SomeType(val data1: Any, val data2: Any)\n\n// ensure that the resulting type has the same value in the data1 field\ndef f(a: Int)(b: SomeType): SomeType(b.data)\n")),(0,r.kt)("h2",{id:"common-issues"},"Common Issues"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note")),(0,r.kt)("p",null,"Many issues that you come across while developing with scala can often be easily identified and solved, especially if you are using a modern dev environment with an LSP (Metals). Being able to pay attention to the error messages that you get in the ",(0,r.kt)("inlineCode",{parentName:"p"},"PROBLEMS")," panel on VSCode and that is about half of the work already."),(0,r.kt)("p",null,"Now there are some more tricky and complex problems that can often arise, many of which are not really even object level issues, but rather meta level issues. Perhaps you screwed up your SBT configuration, if so, metals should tell you all about it in the output section."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Gotchas")),(0,r.kt)("p",null,"In scala, there's a bunch of things that can really get you if you don't really know the semantics of the language deeply. Common ones include:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Class parameters"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"class C:\n  r: Int // scala is not java, this is not idiomatic. If you want something like this you would parameterize the class itself \n\n// like so\n// but this makes `r` a private, immutable field\nclass C(r: Int)\n\n// what you probably want is\nclass C(var r: Int)\n\n// but what you probably should have is\nclass C(val r: Int)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Case Classes, ADTs, Pattern Matching")),(0,r.kt)("p",null,"In Scala, ADTs and Pattern Matching have a bit different of a syntax than other languages but is mostly the same in terms of pattern matching semantics. The thing is you can do case classes, which I think is very powerful but also a source of issues."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"class C\n\n// error! B requires a parameter list\ncase class B extends C\n// correct\ncase class B() extends C\n\n// error! when we parameterize an ADT, we need to specify the arguments for each variant\nclass ADT(val v: Any):\n  case Case1\n  ...\n\n// like so\nclass ADT(val v: Any):\n  case Case1 extends ADT(1)\n\n// error!\nclass ADT:\n  case Case1(v: Any, k: String)\n\n// if you want extra data, do\nclass ADT\ncase class Case1(v: Any, k: String) extends ADT\n")))}p.isMDXComponent=!0}}]);