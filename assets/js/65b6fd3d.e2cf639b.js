"use strict";(self.webpackChunkprojects=self.webpackChunkprojects||[]).push([[695],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>p});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=c(n),p=a,h=u["".concat(l,".").concat(p)]||u[p]||d[p]||o;return n?i.createElement(h,r(r({ref:t},m),{},{components:n})):i.createElement(h,r({ref:t},m))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6683:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const o={sidebar_position:1},r="Dynamic Design Theory",s={unversionedId:"research/dynamic-design-theory",id:"research/dynamic-design-theory",title:"Dynamic Design Theory",description:"By Jasen Qin.",source:"@site/docs/research/dynamic-design-theory.md",sourceDirName:"research",slug:"/research/dynamic-design-theory",permalink:"/docs/research/dynamic-design-theory",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"research",next:{title:"Latency Sensitive Design",permalink:"/docs/research/latency-sensitive-design"}},l={},c=[{value:"Pt 1. Precursor Fields and Related",id:"pt-1-precursor-fields-and-related",level:2},{value:"Latency Sensitive Design (LSD)",id:"latency-sensitive-design-lsd",level:2},{value:"Modular Design",id:"modular-design",level:2},{value:"Functional Design",id:"functional-design",level:3},{value:"Parametric Components",id:"parametric-components",level:3},{value:"User Centric Design",id:"user-centric-design",level:2},{value:"Pseudo-Dynamism &amp; Continuity/Dynamism Simulation",id:"pseudo-dynamism--continuitydynamism-simulation",level:2},{value:"Pt 2. Language Design",id:"pt-2-language-design",level:2},{value:"Polymorphism",id:"polymorphism",level:2},{value:"Ad Hoc Polymorphism",id:"ad-hoc-polymorphism",level:3},{value:"Parametric Polymorphism &amp; Monomorphism",id:"parametric-polymorphism--monomorphism",level:3},{value:"Not a Science",id:"not-a-science",level:2}],m={toc:c};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"dynamic-design-theory"},"Dynamic Design Theory"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"By Jasen Qin.")),(0,a.kt)("p",null,"How does one design a dynamic system according to its intrinsics? Is there a generic higher order way to reason about it? We want optimise for low latency, high throughput, while maintaining a sense of control and elegance over the model."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"pt-1-precursor-fields-and-related"},"Pt 1. Precursor Fields and Related"),(0,a.kt)("h2",{id:"latency-sensitive-design-lsd"},"Latency Sensitive Design (LSD)"),(0,a.kt)("p",null,"LSD is a related field of DDT concerned with putting latency as the fore."),(0,a.kt)("h2",{id:"modular-design"},"Modular Design"),(0,a.kt)("p",null,"A design principle that subdivides a larger specification into a set of constituent \u201cmodules\u201d, that when combined, perhaps in some order, results in the holistic functioning of the intended system."),(0,a.kt)("h3",{id:"functional-design"},"Functional Design"),(0,a.kt)("p",null,"A function-centric way to look at modular design and kind of a more generic idea of \u201cfunctional programming\u201d. Each constituent \u201cpart\u201d or module of a device should only have one function with minimum side effects on other parts."),(0,a.kt)("h3",{id:"parametric-components"},"Parametric Components"),(0,a.kt)("p",null,"To facilitate communication between each component, a component may require or request functionality from another component via a system of arguments."),(0,a.kt)("h2",{id:"user-centric-design"},"User Centric Design"),(0,a.kt)("p",null,"The goal of the product is for the user to use and approve of. Not to abuse or be a danger to them and the environment. So the best way to check off the criteria is to ensure it actually works in reality. If a user finds something dynamic, then goal achieved. The problem is if they find it dynamic for some other reason. We want to be able to directly correlate market success with design and implementation."),(0,a.kt)("h2",{id:"pseudo-dynamism--continuitydynamism-simulation"},"Pseudo-Dynamism & Continuity/Dynamism Simulation"),(0,a.kt)("p",null,"Sometimes its quite hard to make a system feel dynamic. In that case, it is possible to consider ways to \u201csimulate\u201d dynamism so that despite the underlying system being mostly static, the resulting product still feels refreshing."),(0,a.kt)("p",null,"One area where this can be applied is video capture through discrete frames. Even though all we\u2019re doing is looping through each frame, if we do it fast enough and capture each frame close enough to the next, it results in something that looks continuous and \u201cdynamic\u201d. This can also be applied to animations and computer screens which output GUIs and games. The underlying systems are complex and seemingly static like gpus, cpus, busses, video cables, monitors, etc."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"pt-2-language-design"},"Pt 2. Language Design"),(0,a.kt)("p",null,"How do we apply dynamic design to programming languages to make them more elegant and dynamic to the programmer?"),(0,a.kt)("h2",{id:"polymorphism"},"Polymorphism"),(0,a.kt)("p",null,"Instead of writing each piece functionality separately for each type, maybe there is a way to unify similar functionality over different types? Perhaps we could write an interface which types can implement and automatically inherit."),(0,a.kt)("h3",{id:"ad-hoc-polymorphism"},"Ad Hoc Polymorphism"),(0,a.kt)("p",null,"Usually involves method shadowing and virtual function lookup. Bad idea cause generally extra steps involved and not as optimisable statically. May save some memory? Nah cause your implemented functions are different instances anyway. AD hoc polymorphism does not have to be a fundamental part of your type system. You just need a way to to make functions do separate things when applied to different types. Fn overloading and Op overloading can be implemented via ad hoc polymorphism."),(0,a.kt)("p",null,"Naively, languages implement dynamism ad hoc with runtime-dynamic code (RDC). This is simple and intuitive for the programmer and may result in less code generated, promoting cache friendliness. However, ad hoc runtime dynamism usually has a higher overhead since it has to do more checks, e.g. dynamically check a variable. This can be mitigated through effective caching of already computed values, lazy evaluation, common path speculative execution, branch prediction."),(0,a.kt)("p",null,"By doing so, we get \u201cdynamic programming\u201d which involves techniques to cache computed results that are expected again in the future, preferably many times more, otherwise the caching cost might not be worth it. There are many ways to exploit ad hoc runtime dynamism and optimise it work well on a specific platform."),(0,a.kt)("h3",{id:"parametric-polymorphism--monomorphism"},"Parametric Polymorphism & Monomorphism"),(0,a.kt)("p",null,"Parametric programming is when the behaviour of a function is similar regardless of the types its operating on. Perhaps you require the types to be restrained in a particular way; the type itself is irrelevant, only its derived or implemented behaviours which match a specific class of behaviours."),(0,a.kt)("h2",{id:"not-a-science"},"Not a Science"),(0,a.kt)("p",null,"So even though concepts like static and dynamic dispatch exist, they are not a science. People will say \u201cgenerally do X\u201d or \u201cgenerally do Y in this other case\u201d. They won\u2019t say \u201cdo X in a Z manner to gain a 20% decrease in overall latency in system S\u201d, because 1. its quite complex, 2. we want general advice and there are many different platforms, 3. it hasn\u2019t been studied formally."))}d.isMDXComponent=!0}}]);