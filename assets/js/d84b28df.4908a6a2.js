"use strict";(self.webpackChunkprojects=self.webpackChunkprojects||[]).push([[379],{3905:(e,n,r)=>{r.d(n,{Zo:()=>m,kt:()=>u});var t=r(7294);function a(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function i(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?i(Object(r),!0).forEach((function(n){a(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function p(e,n){if(null==e)return{};var r,t,a=function(e,n){if(null==e)return{};var r,t,a={},i=Object.keys(e);for(t=0;t<i.length;t++)r=i[t],n.indexOf(r)>=0||(a[r]=e[r]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)r=i[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=t.createContext({}),s=function(e){var n=t.useContext(l),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},m=function(e){var n=s(e.components);return t.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},d=t.forwardRef((function(e,n){var r=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,m=p(e,["components","mdxType","originalType","parentName"]),d=s(r),u=a,f=d["".concat(l,".").concat(u)]||d[u]||c[u]||i;return r?t.createElement(f,o(o({ref:n},m),{},{components:r})):t.createElement(f,o({ref:n},m))}));function u(e,n){var r=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=d;var p={};for(var l in n)hasOwnProperty.call(n,l)&&(p[l]=n[l]);p.originalType=e,p.mdxType="string"==typeof e?e:a,o[1]=p;for(var s=2;s<i;s++)o[s]=r[s];return t.createElement.apply(null,o)}return t.createElement.apply(null,r)}d.displayName="MDXCreateElement"},3161:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>p,toc:()=>s});var t=r(7462),a=(r(7294),r(3905));const i={sidebar_position:4},o="Rei",p={unversionedId:"base/rei",id:"base/rei",title:"Rei",description:"Rei is a minimalist programming language built to for optimal systems design. Backward compatibility is not an excuse, and in Rei, many FFIs and legacy APIs and ideals may not even be supported at all.",source:"@site/docs/base/rei.md",sourceDirName:"base",slug:"/base/rei",permalink:"/docs/base/rei",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"main",previous:{title:"Universal Creator",permalink:"/docs/base/universal-creator"},next:{title:"Nova",permalink:"/docs/base/nova"}},l={},s=[{value:"Rei VM",id:"rei-vm",level:2},{value:"Base Language Specification",id:"base-language-specification",level:2}],m={toc:s};function c(e){let{components:n,...r}=e;return(0,a.kt)("wrapper",(0,t.Z)({},m,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"rei"},"Rei"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://hyperswine.github.io/rei"},"Rei")," is a minimalist programming language built to for optimal systems design. Backward compatibility is not an excuse, and in Rei, many FFIs and legacy APIs and ideals may not even be supported at all."),(0,a.kt)("p",null,"Rei allows one to do anything imaginable. It is a beyonder language whose job is to take the hardware beyond unenlightenment."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://hyperswine.github.io/rei"},"Check it out!")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Libraries:"),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"core")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"std"),". Stdliberals are needed whether you like them or not",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"core::arch")," for complete wrappers around platform dependent primitives"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"std::spectro"),", an actual functional HDL for building all sorts of hardware"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"arcen"),", a very light gui framework")),(0,a.kt)("h2",{parentName:"admonition",id:"what-can-you-do"},"What can you do?"),(0,a.kt)("p",{parentName:"admonition"},"With less enlightened languages, one may be forced into a specific programming style. I don't mean intentional programming or modular programming. I mean OOP (object oriented pain), 10-line templates, make, etc."),(0,a.kt)("p",{parentName:"admonition"},"Rei on the other hand, just works. Its base spec is quite simple and does not have many rules. If you want to code for embedded, you choose a low level of abstraction ",(0,a.kt)("inlineCode",{parentName:"p"},"core"),". If you want a higher level, use ",(0,a.kt)("inlineCode",{parentName:"p"},"std")," or your own abstractions ontop of the base language."),(0,a.kt)("p",{parentName:"admonition"},"This means one can write anything very concisely and elegantly. The compiler does not thow a hissy fit and everything flows (phanta rei). This includes anything ranging from kernels, firmware, userspace tools, full desktop or web apps, games, and scientific computing. The strict, default constness of rei also ensures safety and validity at compile time.")),(0,a.kt)("p",null,"Don't know how it works? Try it in ",(0,a.kt)("inlineCode",{parentName:"p"},"rein"),", a lightweight environment built specifically for rei development. It has a full language analyzer (not server) that actively prevents you from doing something potentially bad.\n:::"),(0,a.kt)("h2",{id:"rei-vm"},"Rei VM"),(0,a.kt)("p",null,"Even though rei is meant to be a language for neutron core and app development, it works in a VM too (also riscv and arm, but we'll talk about that later)."),(0,a.kt)("p",null,"The VM is pretty much a complete platform for running rei programs. Most std functionalities just work. ",(0,a.kt)("inlineCode",{parentName:"p"},"core::arch")," are specific to platforms your developing for."),(0,a.kt)("admonition",{title:"Progress List",type:"info"},(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},"Drew up codebase for main libraries"),(0,a.kt)("li",{parentName:"ul"},"Refactor the idea to take arbitrary expressions and treat macros like any other keyword"),(0,a.kt)("li",{parentName:"ul"},"Ability to treat macros like any other function and simply use them by including the base prelude library which exports ",(0,a.kt)("inlineCode",{parentName:"li"},"Expr")," among other parser nodes"))),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Implementation of each component and tests in rust"),(0,a.kt)("li",{parentName:"ul"},"Type inference and smart consteval and caching")),(0,a.kt)("p",null,":::"),(0,a.kt)("h2",{id:"base-language-specification"},"Base Language Specification"),(0,a.kt)("p",null,"Expressions, expressions, expressions."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'// \' \' means any whitespace. Means follow\n// ~ means horizontal whitespace. Means directly follow\n// identation and whitespace is significant\n// newlines are significant and marks a new expression in most cases\n// or the body of a nested expression\n\nexpr:\n    | paren_expr\n    | empty_expr\n    | bracket_list_expr\n    | unary_op\n    | binary_op\n    | ternary_op\n    | general_def\n    | scope_expr\n    | modified_scope_expr\n    | var_def_expr\n    | literal_expr\n    | ident_expr\n    | ident_list_expr\n    | comma_expr\n\n// GENERAL DEF\ngeneral_def: raw_ident generic_param_expr? ":" general_def_type\ngeneral_def_type: parameterised_expr | ("extend"? algebraic_expr) | mod_scope | replace_expr\ngeneric_param_expr: "[" generic_param* "]"\ngeneric_param: (raw_ident ~ ":")? ident impl_expr?\n\n// ALGEBRAIC\nalgebraic_expr: alias_expr | enum_expr | product_expr\nalias_expr: ident\nenum_expr: ("enum" scope_expr) | (ident ("|" ident)+)\n\n// PARAMETERISED\nparameterised_expr: paren_param_list+ ret_type? (eval_expr | scope_expr)\nparen_param_list: "(" param ("," param)* ")"\nparam: raw_ident type_expr? refinements?\ntype_expr: ":" ident arg_expr?\nrefinements: refinement ("," refinement)*\nrefinement: unary_refinement_op ident_or_literal\n\nimpl_expr: "impl" ident ("+" ident)*\n\nreplace_expr: "replace" parameterised_expr | scope_expr\n\ncall_expr: expr ~ "(" comma_expr ")"\n\n\nraw_ident: pub_ident | priv_ident\npriv_ident: "_"pub_ident\npub_ident: "[a-zA-Z][\\w\\d_]"\n\nident_or_literal: ident | literal\n\nident: namespaced_ident\nnamespaced_ident: raw_ident ("::"raw_ident)*\n\nliteral_expr: numeric | string\n\neval_expr: "=>" expr\n\ncomma_expr[expr]: expr ~ ("," expr)* ","?\nempty_expr: "(" ")"\nbracket_expr: "[" expr "]"\nbracket_list_expr: bracket_expr\nvar_def_expr: "let" | "mut" | "const" ident "=" expr\nternary_op: (expr ~ "?" ~ expr ":" expr) | (expr ~ "?:" expr)\n\nkeywords: "return" | "async" | "await" | "yield" | "export" | "mod" | "trait" | "impl" | "deref" | "ref"\n\n// OPERATORS [Increasing Order Precedence]\nbinary_op: expr ~ binary_operator ~ expr\nbinary_operator: "&" | "|" | "^" | "*" | "/" | "+" | "-" | "==" | "="\npostfix_unary_operator: "?" | "!"\nprefix_unary_operator: "~" | "*" | "&"\nunary_refinement_op: binary_operator\nself_op: "."\n\nrefinement_expr: expr\n\n// MACROS\nscope_expr: "{" expr* "}"\nmodified_scope_expr: m1_expr | m2_expr\nm1_expr: raw_ident ~ scope_expr\nm2_expr: raw_ident ~ macro_params? scope_expr\n')))}c.isMDXComponent=!0}}]);